/*
 *   MIT License
 *
 *   Copyright (c) 2024, Mattias Aabmets
 *
 *   The contents of this file are subject to the terms and conditions defined in the License.
 *   You may not use, modify, or distribute this file except in compliance with the License.
 *
 *   SPDX-License-Identifier: MIT
 */

import fsp from "node:fs/promises";
import path from "node:path";
import utils from "@src/utils";
import * as t from "@types";

const NOTICE = utils.dedent(`
   // NOTICE: THIS FILE WAS GENERATED BY AUTOMATE-ELECTRON-IPC PLUGIN.
   // YOU MAY ONLY ADD SHEBANG AND/OR LICENSE HEADER ABOVE THIS NOTICE.
`);

export async function initFileContents(filePath: string): Promise<string[]> {
   let fileContents = "";
   const out: string[] = [];
   const stat = await fsp.stat(filePath).catch(() => null);
   if (stat?.isFile()) {
      fileContents = (await fsp.readFile(filePath)).toString();
   }
   const header = utils.extractFileHeader(fileContents);
   header.shebang ? out.push(header.shebang.trim()) : null;
   header.license ? out.push(header.license.trim()) : null;
   out.push(`\n${NOTICE.trim()}\n`);
   return out;
}

export function getOriginalParams(spec: t.FuncSpec): string {
   return spec.params
      .map((param) => {
         return `${param.name}: ${param.type || "unknown"}`;
      })
      .join(", ");
}

export function getAnonymousParams(spec: t.FuncSpec): string {
   const params: string[] = [];
   spec.params.forEach(() => {
      params.push(`arg${params.length + 1}`);
   });
   return params.join(", ");
}

export async function writeMainBindings(
   option: t.IPCAutomationOption,
   config: t.IPCAssuredConfig,
   collection: t.CollectedSpecs[],
   dryRun = false,
): Promise<string> {
   const mainBindingsFile = path.join(option.mainHandlersDir, "index.ts");
   const out = await initFileContents(mainBindingsFile);
   const indent = " ".repeat(config.codeIndent);

   out.push('import { ipcMain } from "electron";');
   const handlers: [string, string][] = [];

   for (const item of collection) {
      if (item.relativePath.startsWith("index")) {
         continue;
      }
      const namespace = utils.digestData(item.relativePath).slice(0, config.namespaceLength);
      const importPath = utils.getImportPath(item.relativePath);
      out.push(`import * as _${namespace} from "./${importPath}";`);

      for (const spec of item.parsedSpecs.funcSpecArray) {
         const params = getAnonymousParams(spec);
         const channel = utils
            .digestData(option, item.fullPath, spec.name)
            .slice(0, config.channelIdentifierLength);
         const arrowParams = spec.params.length === 0 ? "()" : `(_, ${params})`;
         const funcCall = `_${namespace}.${spec.name}(${params})`;
         handlers.push([
            `${indent}ipcMain.handle("${channel}", ${arrowParams} => ${funcCall});`,
            `${indent}ipcMain.removeHandler("${channel}");`,
         ]);
      }
   }
   out.push("\nexport function bindAllHandlers() {");
   handlers.forEach((handler) => out.push(handler[0]));
   out.push("}");

   out.push("\nexport function unbindAllHandlers() {");
   handlers.forEach((handler) => out.push(handler[1]));
   out.push("}\n");

   out.push("export default { bindAllHandlers, unbindAllHandlers };");

   const outStr = out.join("\n");
   if (!dryRun) {
      const indexFile = path.join(option.mainHandlersDir, "index.ts");
      await fsp.writeFile(indexFile, outStr);
   }
   return outStr;
}

export async function writePreloadBindings(
   option: t.IPCAutomationOption,
   config: t.IPCAssuredConfig,
   collection: t.CollectedSpecs[],
   dryRun = false,
): Promise<string> {
   const out = await initFileContents(option.browserPreloadFile);
   const indent = " ".repeat(config.codeIndent);

   out.push('import { contextBridge, ipcRenderer } from "electron/renderer";');
   const handlers: string[] = [];

   for (const item of collection) {
      if (item.relativePath.startsWith("index")) {
         continue;
      }
      for (const spec of item.parsedSpecs.funcSpecArray) {
         const params = getAnonymousParams(spec);
         const channel = utils
            .digestData(option, item.fullPath, spec.name)
            .slice(0, config.channelIdentifierLength);
         const invokeArgs = `"${channel}"${params ? ", " : ""}${params}`;
         const funcCall = `(${params}) => ipcRenderer.invoke(${invokeArgs})`;
         handlers.push(`${indent}${spec.name}: ${funcCall},`);
      }
   }

   out.push('\ncontextBridge.exposeInMainWorld("ipc", {');
   handlers.forEach((handler) => out.push(handler));
   out.push("});\n");

   const outStr = out.join("\n");
   if (!dryRun) {
      await fsp.writeFile(option.browserPreloadFile, outStr);
   }
   return outStr;
}

export async function writeRendererTypes(
   option: t.IPCAutomationOption,
   config: t.IPCAssuredConfig,
   collection: t.CollectedSpecs[],
   dryRun = false,
): Promise<null | string> {
   const out = await initFileContents(option.rendererTypesFile);
   const indent = " ".repeat(config.codeIndent);
   const handlers: string[] = [];

   for (const item of collection) {
      if (item.relativePath.startsWith("index")) {
         continue;
      }
      const importSpecArray = item.parsedSpecs.importSpecArray;
      const typeSpecArray = item.parsedSpecs.typeSpecArray;
      const funcSpecArray = item.parsedSpecs.funcSpecArray;
      const funcCustomTypes: Set<string> = new Set();

      for (const funcSpec of funcSpecArray) {
         const params = getOriginalParams(funcSpec);
         const funcCall = `(${params}) => ${funcSpec.returnType}`;
         handlers.push(`${indent.repeat(3)}${funcSpec.name}: ${funcCall},\n`);
         funcSpec.customTypes.forEach((item) => funcCustomTypes.add(item));
      }
      for (const fct of funcCustomTypes) {
         const [namespace, customType] = utils.splitTypeNamespace(fct);
         const importSpec = importSpecArray.find((spec) => {
            return spec.namespace === namespace || spec.customTypes.includes(customType);
         });
         const typeSpec = typeSpecArray.find((spec) => {
            return spec.name === customType;
         });

         if (typeSpec && !importSpec) {
            if (typeSpec.isExported) {
               const mhdName = path.basename(option.mainHandlersDir);
               const importPath = utils.adjustImportPath(
                  utils.getImportPath(mhdName, item.relativePath),
                  item.fullPath,
                  option.rendererTypesFile,
               );
               out.push(`import type { ${customType} } from "./${importPath}";`);
            } else {
               const part1 = `${typeSpec.kind} '${typeSpec.name}'`;
               const part2 = `must be exported from file:\n${item.fullPath}\n`;
               throw new Error(`${part1} ${part2}`);
            }
         } else if (importSpec) {
            const importPath = utils.adjustImportPath(
               importSpec.fromPath,
               item.fullPath,
               option.rendererTypesFile,
            );
            if (importSpec.customTypes.includes(customType)) {
               out.push(`import type { ${customType} } from "${importPath}";`);
            } else if (importSpec.namespace === namespace) {
               out.push(`import * as ${namespace} from "${importPath}";`);
            }
         }
      }
   }
   const contents = [
      "\ndeclare global {\n",
      `${indent}interface Window {\n`,
      `${indent.repeat(2)}ipc: {\n`,
      handlers.join(""),
      `${indent.repeat(2)}};\n`,
      `${indent}}\n}\n`,
   ].join("");
   out.push(contents);

   const outStr = out.join("\n");
   if (!dryRun) {
      await fsp.writeFile(option.rendererTypesFile, outStr);
   }
   return outStr;
}

export default {
   initFileContents,
   getOriginalParams,
   getAnonymousParams,
   writeMainBindings,
   writePreloadBindings,
   writeRendererTypes,
};
