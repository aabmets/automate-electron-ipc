/*
 *   MIT License
 *
 *   Copyright (c) 2024, Mattias Aabmets
 *
 *   The contents of this file are subject to the terms and conditions defined in the License.
 *   You may not use, modify, or distribute this file except in compliance with the License.
 *
 *   SPDX-License-Identifier: MIT
 */

import fsp from "node:fs/promises";
import path from "node:path";
import type { CollectedSpecs, FuncSpec, IPCAssuredConfig, IPCAutomationOption } from "@types";
import utils from "@utils";

const NOTICE = utils.dedent(`
   // NOTICE: THIS FILE WAS GENERATED BY AUTOMATE-ELECTRON-IPC PLUGIN.
   // YOU MAY ONLY ADD SHEBANG AND/OR LICENSE HEADER ABOVE THIS NOTICE.
`);

export async function initFileContents(filePath: string): Promise<string[]> {
   let fileContents = "";
   const out: string[] = [];
   const stat = await fsp.stat(filePath);
   if (stat.isFile()) {
      fileContents = (await fsp.readFile(filePath)).toString();
   }
   const header = utils.extractFileHeader(fileContents);
   header.shebang ? out.push(header.shebang.trim()) : null;
   header.license ? out.push(header.license.trim()) : null;
   out.push(`\n${NOTICE.trim()}\n`);
   return out;
}

export function getOriginalParams(spec: FuncSpec): string {
   return spec.params
      .map((param) => {
         return `${param.name}: ${param.type || "unknown"}`;
      })
      .join(", ");
}

export function getAnonymousParams(spec: FuncSpec): string {
   const params: string[] = [];
   spec.params.forEach(() => {
      params.push(`arg${params.length + 1}`);
   });
   return params.join(", ");
}

export async function writeMainBindings(
   option: IPCAutomationOption,
   config: IPCAssuredConfig,
   collection: CollectedSpecs[],
): Promise<void> {
   const mainBindingsFile = path.join(option.mainHandlersDir, "index.ts");
   const out = await initFileContents(mainBindingsFile);
   const indent = " ".repeat(config.codeIndent);

   out.push('import { ipcMain } from "electron";');
   const handlers = [];

   for (const item of collection) {
      if (item.relativePath.startsWith("index")) {
         continue;
      }
      const namespace = utils.digestData(item.relativePath).slice(0, config.namespaceLength);
      const importPath = utils.getImportPath(item.relativePath);
      out.push(`import * as _${namespace} from "./${importPath}";`);

      for (const spec of item.parsedSpecs.funcSpecArray) {
         const params = getAnonymousParams(spec);
         const channel = utils
            .digestData(option, item.fullPath, spec.name)
            .slice(0, config.channelIdentifierLength);
         const arrowParams = spec.params.length === 0 ? "()" : `(_, ${params})`;
         const funcCall = `_${namespace}.${spec.name}(${params})`;
         handlers.push([
            `${indent}ipcMain.handle("${channel}", ${arrowParams} => ${funcCall});`,
            `${indent}ipcMain.removeHandler("${channel}");`,
         ]);
      }
   }
   out.push("\nexport function bindAllHandlers() {");
   handlers.forEach((handler) => out.push(handler[0]));
   out.push("}");

   out.push("\nexport function unbindAllHandlers() {");
   handlers.forEach((handler) => out.push(handler[1]));
   out.push("}\n");

   out.push("export default { bindAllHandlers, unbindAllHandlers };");

   const indexFile = path.join(option.mainHandlersDir, "index.ts");
   await fsp.writeFile(indexFile, out.join("\n"));
}

export default {
   initFileContents,
   getOriginalParams,
   getAnonymousParams,
   writeMainBindings,
};
