/*
 *   Apache License 2.0
 *
 *   Copyright (c) 2024, Mattias Aabmets
 *
 *   The contents of this file are subject to the terms and conditions defined in the License.
 *   You may not use, modify, or distribute this file except in compliance with the License.
 *
 *   SPDX-License-Identifier: Apache-2.0
 */

import fsp from "node:fs/promises";
import path from "node:path";
import type * as t from "@types";
import { ImportsGenerator } from "./imports-generator.js";

export class BaseWriter {
   protected importsGenerator: ImportsGenerator;
   protected resolvedConfig: t.IPCResolvedConfig;
   protected pfsArray: t.ParsedFileSpecs[];
   protected indents: string[];
   protected notice = [
      "\n// NOTICE: THIS FILE WAS GENERATED BY AUTOMATE-ELECTRON-IPC PLUGIN.",
      "// ANY MANUAL CHANGES TO THIS FILE WILL NOT PERSIST BETWEEN GENERATIONS.\n",
   ].join("\n");

   public constructor(resolvedConfig: t.IPCResolvedConfig, pfsArray: t.ParsedFileSpecs[]) {
      if (this.constructor === BaseWriter) {
         throw new Error(`Cannot instantiate abstract base class '${this.constructor.name}'`);
      }
      this.pfsArray = pfsArray;
      this.resolvedConfig = resolvedConfig;
      this.importsGenerator = new ImportsGenerator(this.getTargetFilePath());
      this.indents = this.getCodeIndents();
   }

   private throwAbstractError(methodName: string): void {
      throw new Error(`Must implement method '${methodName}' in '${this.constructor.name}' class`);
   }

   protected getTargetFilePath(): string {
      this.throwAbstractError("getTargetFilePath");
      return null as unknown as string;
   }

   protected renderFileContents(): string {
      this.throwAbstractError("generateFileContents");
      return null as unknown as string;
   }

   protected getCodeIndents(): string[] {
      return [1, 2, 3, 4].map((value) => {
         return " ".repeat(this.resolvedConfig.codeIndent).repeat(value);
      });
   }

   protected sortCallablesByPrefix(callables: string[]): string[] {
      return callables.sort((a, b) => {
         const prefixOrder = ["on", "send", "port"];
         const getPrefixRank = (value: string) => {
            for (let i = 0; i < prefixOrder.length; i++) {
               if (value.startsWith(prefixOrder[i])) {
                  return i;
               }
            }
            return prefixOrder.length;
         };
         return getPrefixRank(a) - getPrefixRank(b);
      });
   }

   protected injectEventTypehint(sigDef: string): string {
      return sigDef.replace("(", "(event: IpcMainEvent, ");
   }

   protected getOriginalParams(spec: t.ChannelSpec, withTypes: boolean): string {
      return spec.signature.params
         .map((param) => {
            const typeHint = withTypes ? `: ${param.type || "any"}` : "";
            return `${param.name}${typeHint}`;
         })
         .join(", ");
   }

   public async write() {
      const targetFilePath = this.getTargetFilePath();
      const fileDirectory = path.dirname(targetFilePath);
      await fsp.mkdir(fileDirectory, { recursive: true });
      await fsp.writeFile(targetFilePath, this.renderFileContents());
   }
}
