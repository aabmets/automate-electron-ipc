/*
 *   Apache License 2.0
 *
 *   Copyright (c) 2024, Mattias Aabmets
 *
 *   The contents of this file are subject to the terms and conditions defined in the License.
 *   You may not use, modify, or distribute this file except in compliance with the License.
 *
 *   SPDX-License-Identifier: Apache-2.0
 */

import path from "node:path";
import type * as t from "@types";

export function initFileContents(): string[] {
   return [
      "\n// NOTICE: THIS FILE WAS GENERATED BY AUTOMATE-ELECTRON-IPC PLUGIN.",
      "// ANY MANUAL CHANGES TO THIS FILE WILL NOT PERSIST BETWEEN GENERATIONS.",
   ];
}

export function getOriginalParams(spec: t.ChannelSpec): string {
   return spec.signature.params
      .map((param) => {
         return `${param.name}: ${param.type || "unknown"}`;
      })
      .join(", ");
}

export function getAnonymousParams(spec: t.ChannelSpec): string {
   const params: string[] = [];
   spec.signature.params.forEach(() => {
      params.push(`arg${params.length + 1}`);
   });
   return params.join(", ");
}

/**
 * Adjusts the relative path of an import statement when moving between two modules.
 *
 * @param importPath - The relative import path as a string.
 * @param sourceFilePath - The fully resolved path of the module where the import originates.
 * @param targetFilePath - The fully resolved path of the module where the import will be inserted.
 * @returns The adjusted relative import path for the target module.
 */
export function adjustImportPath(
   importPath: string,
   sourceFilePath: string,
   targetFilePath: string,
): string {
   if (importPath.startsWith(".")) {
      const sourceDir = path.dirname(sourceFilePath);
      const targetDir = path.dirname(targetFilePath);

      const importAbsolutePath = path.normalize(path.join(sourceDir, importPath));
      let adjustedPath = path.relative(targetDir, importAbsolutePath);
      adjustedPath = adjustedPath.replace(/\\/g, "/");

      if (!["..", "./"].includes(adjustedPath.slice(0, 2))) {
         adjustedPath = `./${adjustedPath}`;
      }
      return adjustedPath;
   }
   return importPath;
}

/**
 * Joins multiple filesystem path segments, converts the result to a normalized
 * import path by replacing all path separators with forward slashes, and removes
 * the file extension.
 *
 * @param paths - Multiple filesystem path segments to join and normalize.
 * @returns The joined and normalized import path without the file extension.
 */
export function getImportPath(...paths: string[]): string {
   const joined = path.join(...paths);
   const normalizedPath = joined.replaceAll(path.sep, "/");
   const ext = path.extname(normalizedPath);
   return normalizedPath.slice(0, normalizedPath.length - ext.length);
}

/**
 * Separates any namespace from the type name and returns both of them as an array.
 *
 * @param typeName - The type name, potentially being prefixed by a namespace
 * @returns The namespace and the type name. If typeName was not prefixed with
 *          any namespace, the first value in the array will be null.
 */
export function splitTypeNamespace(typeName: string): [string | null, string] {
   const [value1, value2] = typeName.split(".", 2);
   return value2 ? [value1, value2] : [null, value1];
}

export function getCodeIndents(config: t.IPCResolvedConfig): string[] {
   return [1, 2, 3, 4].map((value) => {
      return "\u00A0".repeat(config.codeIndent).repeat(value);
   });
}

export function sortByPrefix(callables: string[]): string[] {
   return callables.sort((a, b) => {
      const prefixOrder = ["on", "send", "port"];

      const getPrefixRank = (value: string) => {
         for (let i = 0; i < prefixOrder.length; i++) {
            if (value.startsWith(prefixOrder[i])) {
               return i;
            }
         }
         return prefixOrder.length;
      };
      return getPrefixRank(a) - getPrefixRank(b);
   });
}

export default {
   initFileContents,
   getOriginalParams,
   getAnonymousParams,
   adjustImportPath,
   getImportPath,
   splitTypeNamespace,
   getCodeIndents,
   sortByPrefix,
};
